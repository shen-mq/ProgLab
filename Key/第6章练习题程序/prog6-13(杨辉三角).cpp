/*********************************************************************
程序名：杨辉三角
版权：遵从GPL版权协议，可自由使用和传播（请勿上传到收费性网络文库）
作者：anbangli@foxmail.com
日期：2019-07-22
说明：6-13.杨辉三角（也叫帕斯卡三角）是二项式系数在三角形中的一种几何排列。
前几行如下：
第1行：         1
第2行：       1   1
第3行：     1   2   1
第4行：   1   3   3   1
第5行： 1   4   6   4   1
....
杨辉三角的特点是：每行左右两端的元素都是 1，中间的元素是左上角的元素与
右上角的元素之和。写一个程序，计算并输出杨辉三角的前面 12 行。
（提示：第 i 行共有 i 个不为零的元素，彼此之间用 i-1 个值为 0 的元素分隔，
所以 n 行的杨辉三角可用 n ×(2n-1) 的二维数组表示；先设定每行左右两端为 1
的元素，其它元素都设为 0；然后从上往下逐行推导。输出时把值为 0 的元素
 输出为空格。）
*********************************************************************/
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
	const int N = 5;	//行数
	const int M = 2 * N - 1;	//列数：第 N 行有 2N-1 个数字。
	int yh[N][M] = {0};	//定义数组并初始化为0。yh 是 yanghui 的缩写
	int i, j;

	//初始化：第 i 行有 2i-1 个非零数字，且对称的两边数字都为 1。
	//注意：行号是按自然数编号，从 1 开始，而数组下标是从 0 开始编号。
	for (i = 0; i < N; i++) {
		yh[i][N - i- 1] = 1;
		yh[i][N + i -1] = 1;
	}

	//打印输出
	for (i = 0; i < N; i++) {	//行循环
		for (j = 0; j < M ; j++)	//列循环
			//cout << setw(3) << yh[i][j];//直接输出会有大量的 0
			if (yh[i][j] ==0) //元素为 0 时输出空格
				cout << " 0 ";
			else
				cout << " " << yh[i][j] << " ";
		cout << endl;	//每行末尾换行
	}


	//推导：数组中每个数字等于上一行的左右两个数字之和。
	//即第 i 行的第 j 个数等于第 i-1 行的第 j-1 个数和第 j+1 个数之和。
	for (i = 2; i < N; i++) {	//行循环
		for (j = N - i + 1; j < N-2+i; j = j + 2)	//列循环
			yh[i][j] = yh[i - 1][j - 1] + yh[i - 1][j + 1];
	}

	//打印输出
	for (i = 0; i < N; i++) {	//行循环
		for (j = 0; j < M ; j++)	//列循环
			//cout << setw(3) << yh[i][j];//直接输出会有大量的 0
			if (yh[i][j] ==0) //元素为 0 时输出空格
				cout << "   ";
			else
				cout << setw(3) << yh[i][j];
		cout << endl;	//每行末尾换行
	}

//	//另一种解法：不讲究美观显示，而是显示为左斜三角形式。
//	//第 i 行含有 i 个非零元素，彼此之间不用零元素隔开。
//	int a[N][N] = {0};	//用 N*N 的数组存储非零元素。全部初始化为0。
//	//使第一列和对角线元素的值为1 。
//	for(i = 0; i < N; i++) {
//		a[i][0] = 1;
//		a[i][i] = 1;
//	}
//
//	//逐行推导
//	for(i = 2; i <= N; i++)
//		for(j = 1; j < i; j++) {
//			a[i][j] = a[i-1][j] + a[i-1][j-1];
//		}
//
//	//输出数组各元素的值
//	for(i=1; i<=N; i++) {
//		for(j=1; j<=i; j++) {
//			cout << setw(4) << a[i][j];
//		}
//		cout << endl;
//	}

	return 0;
}
//（附加说明：本题中是把杨辉三角的行号按照从 1 开始编号，有些资料上是把
//杨辉三角的行号按照从 0 开始编号，因此在文字说明上可能与本题稍有不同。）

