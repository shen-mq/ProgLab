/*********************************************************************
程序名："约瑟夫环"解法2
版权：遵从GPL版权协议，可自由使用和传播（请勿上传到收费性网络文库）
作者：anbangli@foxmail.com
日期：2019-07-20
说明：
【例6-5】“约瑟夫环”是一个数学上和计算机编程上的经典问题：设有 n 个人
（以编号1，2，3，...，n 分别表示）围成一个圆圈，从编号 m 的人开始由 1
开始报数，每个正好报到数 k 的人退出游戏，后面的一个人重新由 1 开始报数，
数到 k 的那个人又出列；依此规律重复下去，直到只剩下最后一人。求最后剩下
那个人的编号。

6-7.求解约瑟夫问题时，也可以用数组的值表示人员的编号（例如，开始时在
数组中存储有“1 2 3 4 5 6 7 8”共 8 个值），每次有一人退出时则把该编号
从数组中移除（例如，首次是编号为 5 的人退出，则把数组中后面的数据前移，
变成“1 2 3 4 6 7 8 8”），然后所处理的数组元素个数 n 减 1，重复这样
操作，直到 n 变到 1 为止。请按这种思路编写程序解答约瑟夫问题。
（附带提示：报数时不需要逐个计数，而用当前下标加 k 之后对 n 取余即可得
下一个）
*********************************************************************/

#include <iostream>
using namespace std;

int main() {
	enum {NUM = 100};	//数组最大长度
	int h[NUM]; 	//存放人员编号的数组
	int n, m, k, i;	//队伍原有 n 人，从编号为 m 的人开始，每报数到 k 即退出。

	for (i = 0; i < NUM; ++i) //根据题目要求，把人员原始编号存放于数组中
		h[i] = i + 1;	//数组下标是0～NUM-1, 原始编号是自然数 1～ N

	//cout << "请输入 n( < " << NUM << "), m, k: ";
	//cin >> n >> m >> k;
	n = 9; 	m = 4;	k =3; 	//示例数据
	cout << "n= " << n << "\tm= " << m << "\tk= " << k << endl;

	m--;	//!!起始报数的人员原始编号转换为数组元素下标来考虑（编号 m 对应于下标 m-1）

	cout << "原始队伍：";
	for (i = 0; i < n; ++i) 	//打印输出
		cout << h[i] << (i != m ? "  " : "m ");
	cout << endl;

	while (n > 1) {	//每次有一人退出时则把该编号从数组中移除，直到总人数 n 变到 1 为止。
		//当前人员从1开始报数，实际上只需往后计数 k-1 人
		m = (m + k - 1) % n;	//!! 以取余方式直接得到报数 k 的人在剩余队伍中的下标）

		cout << "退出一人：";
		for (i = 0; i < n; ++i) 	//打印输出，退出人员带有标记 k
			cout << h[i] << (i != m ? "  " : "k ");
		cout << endl;

		n--;	//!! 队伍总人数减 1
		for(i = m; i < n; ++i)	//!! 后面的编号往前移一位
			h[i] = h[i+1];

		cout << "重排队伍：";
		for (i = 0; i < n; ++i) 	//打印输出
			cout << h[i] << (i != n-1? "  " : "\n");
	}
	cout << "最后一人的原始编号：" << h[0];

	return 0;
}

