/*********************************************************************
程序名：求 PI 的近似值
版权：遵从GPL版权协议，可自由使用和传播（请勿上传到收费性网络文库）
作者：anbangli@foxmail.com
日期：2019-08-09
说明：
4-3.（注意整除与浮点误差）已知 sigma(1/n^2) = pai^2/6 ，
利用该公式编程序求 π 的近似值，看用这个和式的前多少项求出的近似值与
3.1415927的误差分别小于10^-5、10^-6 和 10^-7。程序每次达到所需精度时
输出三项数据：达到所需误差所用的项数，计算得到的公式左边的和，以及由
这个和求出的π的近似值。
（提示：1、最外层用一个循环，分别设置三种误差值，再用内层循环按照该公
式进行计算；2、计算时，程序中不能写成 1/(n*n)，那样会导致整数相除而得0；
也不应写成 1.0/(n*n)，那样当 n 增大时可能导致 n*n 溢出，正确的方式是
写成1.0/n/n；3、输出π的近似值应该保留适当的小数位数。)
*********************************************************************/
#include <iostream>
#include <cmath>	//数学函数 
#include <iomanip>	//输出格式控制 
using namespace std;

int main() {//简洁的方法
	int d, n;	//用 d 控制外层循环，该循环中用 d 计算出所需误差
	double err, sum;	//err 为所需的误差值；sum 为内部循环的累加和

	for (d = 5; d <= 7; d++) {
		err = pow(0.1, d);  //所需误差。
		//也可给 err 赋初值 1E-4，让 d 取值1,2,3，每次 err = err * 0.1

		for(n = 1, sum = 0; fabs(sqrt(6 * sum) - 3.14159266) > err; n++) {
			sum += 1.0 / n / n;	// 关键语句！
			// 不能写成 sum += 1/n*n;  因为 1/n*n 求值为 0。
			// 不能写成 sum += 1/(n*n); 因为 1/(n*n) 求值为 0。
			// 不能写成 sum += 1.0/(n*n)。当 n 增大时容易溢出。

			if (n % 10000 == 0)	//输出中间量以供观察
				cout << n << "\t" << sum << "\t" << setprecision(d) << sqrt(6 * sum) << endl;
		}
		//内层 for 循环每次重新初始化 n 和 sum，在 err 取不同值有重复计算。可设法改进（略）。

		cout << "n= " << n-- << " sum= " << sum << "  pai= "
			<< fixed << setprecision(d) << sqrt(6 * sum) << endl;
	}
	return 0;
}



//int main() {	//稍微复杂点的方法，使用了多个变量，展现了更多细节。
//	long d, n;
//	double err, x, sum;
//	double PI = 3.14159265;  //用全大写标识符表示常变量
//	double pai = 0;	//这个变量要与常变量有明显的区别才好
//
//	for (d = 5; d <= 7; d++) {
//		err = pow(0.1, d);  //所需误差。
//		for (n = 1, sum = 0; fabs(pai - PI)> err; n++) {
//			x = 1.0 / n / n;
//			sum = sum + x;
//			pai = sqrt(sum *6);
//			//if (n % 10000 == 0)
//			//	printf ("n=%d %16.14f s=%10.8f pai=%10.8f\n", n, x, sum, pai);
//		}
//		printf ("n=%d %16.14f s=%10.8f pai=%10.8f\n", n, x, sum, pai);
//	}
//	return 0;
//}

